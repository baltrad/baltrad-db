/**
@page manual Manual

@section toc Table of Contents
<ul>
  <li>@ref intro</li>
  <li>@ref setup</li>
  <li>@ref file_importing</li>
  <ul>
    <li>@ref file_loading</li>
    <li>@ref file_naming</li>
    <li>@ref file_uniqueness</li>
  </ul>
  <li>@ref querying</li>
  <li>@ref removing</li>
  <li>@ref java_bindings</li>
  <li>@ref java_samples</li>
</ul>

@section intro Introduction

baltrad-db is a library for storing the metadata contained in ODIM_H5 files
in a database and providing queries on the stored metadata.

@section setup Setting Up

The main class for interacting with the library is brfc::FileCatalog.
It requires that you specify a database connection string and a filesystem
directory where it will store imported files. The brfc::FileCatalog instance
created this way uses a brfc::DefaultFileNamer instance for file naming and a
brfc::oh5::AttributeSpecs instance from brfc::rdb::RelationalDatabase.
This is a set of ODIM_H5 metadata attributes the library is aware of, any
attribute encountered and not specified in this set is ignored.

Connection string is specified as a URI, for details, refer to brfc::Database
documentation.

@code
// define database connection
QString dsn("postgresql://baltrad:baltrad@localhost/baltrad");
// define a path where FileCatalog will store files
QString storage_dir("/tmp");

// create a FileCatalog instance, connecting it to database
// and giving it a storage directory
try {
    brfc::FileCatalog fc(dsn, storage_dir);
} catch (const brfc::db_error& e) {
    // problem connecting to database
} catch (const brfc::fs_error& e) {
    // problem accessing storage directory
}
@endcode

@section file_importing Importing files

Importing a file requires feeding an absolute pathname to
brfc::FileCatalog::catalog. This method, on success, returns a pointer
to the brfc::oh5::File instance stored in the database. 

The procedure for importing the file is as follows:
@li the file is loaded from the filesystem (@ref file_loading)
@li a unique identifier is determined (@ref file_uniqueness)
@li a filename for the file is generated  (@ref file_naming)
@li the metadata is stored in the database
@li the file is copied to the storage directory

The assigned path is accessible through brfc::oh5::File::path;

@code
brfc::FileCatalog fc(dsn, storage_dir);

std::shared_ptr<File> file;

try {
    file = fc.catalog("/path/to/file.h5");
} catch (const brfc::db_error& e) {
    // problem storing file in database
} catch (const brfc::fs_error& e) {
    // opening the file failed or problem storing file on filesystem
} catch (const brfc::duplicate_entry& e) {
    // file already stored
}

// absolute path to the stored file
file->path();

// attributes ignored on loading
file->ignored_attributes();

@endcode

@subsection file_loading Loading the file from filesystem

On loading, HDF5 attributes (metadata) are read from file and their values
are converted using a brfc::oh5::Converter. Attributes that are not recognised
are left without a value. These attributes can be accessed through
brfc::oh5::File::ignored_attributes.

Group information is part of the attribute name, so @c /what/date is looked up
and stored as @c what/date.

@subsection file_uniqueness Determining file uniqueness

See brfc::oh5::File::unique_identifier for now.

@subsection file_naming Naming the file

First the brfc::FileNamer instance is asked to name the file. The database
keeps track of all the proposed filenames and version numbers assigned to
those. It is queried for a version number for this name and the result is
injected into the filename to form a unique filename.

@section querying Querying

brfc::Query provides an interface for querying the database using attributes.
You'll probably want to query for files matching certain criteria on an
attribute, so we'll focus on that. You can get hold of a brfc::Query instance
using brfc::FileCatalog::query.

For convenience, a factory for creating elements usable in a query is provided
(brfc::expr::Factory).

File pathname can be queried using a pseudo-attribute named "path", this is the
absolute path of the stored file.

To get an attribute from database, you must mark it for fetching using
brfc::Query::fetch.

To actually run the query, brfc::Query::execute must be called. Granted that no
hickups were encountered, you'll get back a pointer to a brfc::ResultSet instance
containing the values of the attributes you requested.

@code
// assuming we have a filecatalog instance
brfc::FileCatalog fc;
// create expression factory
brfc::expr::Factory xpr;

brfc::Query q = fc.query();

// create "path" attribute
brfc::expr::AttributePtr path = xpr.attribute("path");
// mark it for fetching
q.fetch(path);
// execute
shared_ptr<brfc::ResultSet> r = q.execute();

// loop through results
while (r->next()) {
    // access the values
    QString path = r->string(0);
}
@endcode

Behind the scenes, an SQL query is created, where attributes are replaced
with database columns according to what is specified in brfc::AttributeSpec
entry for the attribute. See @ref query_compilation for details.

Querying for all files is useful, but you probably want to get files with
certain attributes defined. To achive that, you supply your query with
filters using brfc::Query::filter. The filter accepts an arbitrary
brfc::expr::Expression, which you can create using a combination of
literals, comparison operators and logical operators.

For example, let us fetch all polar volumes before 15.05.2009.

@code
// assuming a query
brfc::Query q;
brfc::expr::Factory xpr;

// give back paths
q.fetch(xpr.attribute("path"));
// where date < 15.05.2009
q.filter(xpr.lt(xpr.attribute("what/date"), xpr.date(2009, 5, 15)));
// where object = PVOL
q.filter(xpr.eq(xpr.attribute("what/object"), xpr.string("PVOL")));

brfc::ResultSet r = q.execute();
@endcode

Specifying multiple filters is equivalent to using operator
brfc::expr::Expression::and_ between the filter expressions.

You could also use 'less than operator' straight from the attribute
interface like this:

@code
xpr.attribute("what/date")->lt(xpr.date(2009, 5, 15));
@endcode

@note that when you use an attribute in a filter, that attribute @b MUST
be present in the file metadata. If it's missing, it's not matching and
is thus ignored completely. There is no way to specifiy a missing value
yet (so this is a known limitation in current implementation).

A problem you might encounter is when a file has the same attribute specified
in many datasets. You will get as many rows as the number of values for the
attribute. As in SQL, you can set a query to fetch only distinct rows using
brfc::Query::distinct.


Things are a bit trickier when you want to filter by source. A source in
ODIM_H5 files can contain many attributes. Luckily, when storing the file
it is associated with one distinct source. But you can query using all the
possible fields. A source is split to pseudo-attributes with element names
from ODIM_H5 source specification, prefixed with 'src_'. So WMO becomes
src_WMO and so on. There are two groups of sources: radar sites and
organisations/countries. Their attribute values don't overlap, meaning:
radar sites have WMO, RAD and PLC specified, while the other group has
CTY and ORG.

There is one overlapping attribute though, named src_node, which for
radar sites is the node value from ODIM_H5 specifiaction Table 9, and
for countries/organisations the two-letter internet country code. So
this is present in all sources. But it's not entirely useful right now.
(If there is need, we might introduce sql LIKE operator so you can select
over this attribute to get all country data (including radars) easily like
this: <tt>xpr.attribute("src_node").like("se*");</tt>)

@code
brfc::expr::Factory xpr;

brfc::Query q = fc.query();
q.fetch(xpr.attribute("path"));
q.filter(xpr.attribute("src_node")->eq(xpr.string("seang")));

brfc::ResultSet r = q.execute();
@endcode

@section removing Removing files

File removal is done by path name. Just feed a path relative to storage
root (which you probably get through querying).

for example, removing files older than from 2009.
@code
brfc::FileCatalog fc(dsn, storage_dir);
brfc::expr::Factory xpr;

brfc::Query q = fc.query();

q.fetch(xpr.attribute("path"));
q.filter(xpr.attribute("what/date")->lt(xpr.date(2009, 1, 1)));

brfc::ResultSet r = q.execute();

while (r.next()) {
    try {
        fc.remove(r.get_string(0));
    } catch (const brfc::db_error& e) {
        // removing from database failed
    } catch (const brfc::fs_error& e) {
        // removing from filesystem failed
    }
}
@endcode

@section java_bindings Java bindings

Mapping to Java code is quite straightforward. The main package name is
@c eu.baltrad.fc, this is where namespace brfc is mapped to. All exposed
subnamespaces map to subpackages (brfc::expr is @c eu.baltrad.fc.expr and
so on).

There are a few differences though:

@li brfc::expr::Factory is mapped to @c eu.baltrad.fc.expr.ExpressionFactory
@li brfc::expr::Attribute is mapped to @c eu.baltrad.fc.expr.AttributeExpr
@li brfc::brfc_error is mapped to @c eu.baltrad.fc.FileCatalogError
@li brfc::fs_error is mapped to @c eu.baltrad.fc.FileSystemError
@li brfc::db_error is mapped to @c eu.baltrad.fc.DatabaseError
@li brfc::lookup_error is mapped to @c eu.baltrad.fc.LookupError
@li brfc::duplicate_entry is mapped to @c eu.baltrad.fc.DuplicateEntry


@section java_samples Sample Java code

Querying:

@code
// setting up
String dsn("postgresql://baltrad:baltrad@localhost/baltrad");
String storage_dir("/tmp");
Filecatalog fc;

try {
    fc = new FileCatalog(dsn, storage_dir);
} catch (DatabaseError e) {
    // problem connecting to database
} catch (FileSytemError e) {
    // problem accessing storage directory
}

// querying
ExpressionFactory xpr;

Query q = fc.query_path();
q.filter(xpr.attribute("src_node").eq(xpr.string("seang"));

// execute
ResultSet r = q.execute();

// loop through results
while (r.next()) {
    // access the values
    String path = r.string(0);
}
@endcode

*/
// vim:filetype=doxygen:et:ts=4:sw=4:
