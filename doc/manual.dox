/**
@page manual Manual

@section toc Table of Contents
<ul>
  <li>@ref intro</li>
  <li>@ref setup</li>
  <li>@ref file_storing</li>
  <ul>
    <li>@ref file_loading</li>
    <li>@ref file_naming</li>
    <li>@ref file_uniqueness</li>
  </ul>
  <li>@ref querying</li>
  <ul>
    <li>@ref querying_files</li>
    <li>@ref virtual_attributes</li>
    <li>@ref querying_attributes</li>
    <li>@ref combine_datetime</li>
  <li>@ref removing</li>
  <li>@ref java_bindings</li>
  <li>@ref java_samples</li>
</ul>

@section intro Introduction

baltrad-db is a library for storing ODIM_H5 files in a database and providing
queries on the file metadata.

The central class is brfc::db::Database (with implementation in
brfc::db::rdb::RelationalDatabase). This provides access to the database where
files and metadata are stored.

Another important class is brfc::LocalStorage. This provides access to files in
the local filesystem and can bring files from database to disk.

These instances of these two core classes are tied together for convenience in
brfc::FileCatalog.

@section setup Setting Up

The simplest way to get running is just to give a database URI string to
brfc::FileCatalog, this will create a catalog with brfc::db::RelationalDatabase
instance, connected to the specified database. It will use brfc::NullStorage as
node local storage, meaning it will no store the files in the local filesystem,
just in the database.

@code
// define database connection
brfc::String dsn("postgresql://baltrad:baltrad@localhost/baltrad");

try {
    brfc::FileCatalog fc(dsn);
} catch (const brfc::db_error& e) {
    // problem connecting to database
}
@endcode

@section file_storing Storing files in the database

Importing a file requires feeding an absolute pathname (or a
brfc::oh5::PhysicalFile instance) to brfc::FileCatalog::store.
This method, on success, returns a pointer to a brfc::db::FileEntry
instance. This is the file, as stored in the database.

If you have associated the catalog with a brfc::LocalStorage instance, it will
be given a chance to "prestore" or cache the file in the local filesystem. This
might be handy, as the files imported to the database are probably going to get
used in some way in immediate future. Prestoring them avoids the overhead of
fetching the file back from the database to local disk (opting to copy it on
import).

@code
brfc::FileCatalog fc(...);

std::shared_ptr<FileEntry> file;

try {
    file = fc.catalog("/path/to/file.h5");
} catch (const brfc::db_error& e) {
    // problem storing file in database
} catch (const brfc::duplicate_entry& e) {
    // file already stored
}
@endcode

The procedure for importing the file is as follows.

First, metadata is loaded from the file. Attribute '/what/source' is then
used to look up a source definition in the database. A hash is calculated
over the rest of the metadata. The combination of the source and metadata
hash determines file uniqueness: if such a combo exists, file is taken to
be already stored. Finally a UUID is generated for the file, the metadata
and file content are stored in the database.

@section querying Querying

BDB provides two types of queries: a more flexible brfc::db::AttributeQuery
and a simple way to get brfc::db::FileEntry instances - brfc::db::FileQuery.

@section querying_files Querying files

Lets focus on querying files first. You can get hold of a query instance
using brfc::FileCatalog::query_file. The simplest thing you can do, is
get all brfc::db::FileEntry instances stored in the database, this requires
no work: just create and execute it.

@code
// assuming we have a filecatalog instance
brfc::FileCatalog fc;

brfc::db::FileQuery q = fc.query_file();
shared_ptr<brfc::db::FileResult> r = q.execute();

r->size(); // how many files

// loop through the entries
shared_ptr<brfc::db::FileEntry> entry;
while (r->next()) {
    entry = r->entry();
    // do something useful
}
@endcode

To be more useful, you can add a filter to the query. Filters are composed of
brfc::expr::Expression elements. The easiest way to create these is using
brfc::expr::ExpressionFactory. To give an example:

@code
// create the factory
brfc::expr::ExpressionFactory xpr;

// create the query
brfc::AttributeQuery q = fc.query_file();
q.filter(xpr.eq(xpr.attribute("what/object"), xpr.string("PVOL")));
@endcode

this filters for all files that have an attribute "what/object" and it
contains a string "PVOL".

Successive filters can be given, meaning all specified filters must match and
is equivalent to using operator brfc::expr::Expression::and_ between the filter
expressions.

@note when you use an attribute in a filter, that attribute @b MUST
be present in the file metadata. If it's missing, it's not matching and
is thus ignored completely. There is no way to specifiy a missing value
yet (so this is a known limitation in current implementation).

@section virtual_attributes Virtual attributes

In addition to standard ODIM_H5 attributes, there are some special attributes.
They don't really exist in the metadata and require special handling, but they
are usable in the queries.

Here's a list of them:

  - file\:uuid - universally unique id of the file in database
  - file\:stored_at - when was the file imported to the database
  - src:name - the name of the source in database
  - src:X - source key in database, where X is the source key (PLC, CTY, ...)

@section querying_attributes Querying attributes

Sometimes you will want to query for specific attributes instead of files.
brfc::db::AttributeQuery enables you to do just that. In addition to filtering,
you can specify which attributes to fetch from the database. So to query for
all files in the database, you would do this:

@code
// assuming we have a filecatalog instance
brfc::FileCatalog fc;
// create expression factory
brfc::expr::ExpressionFactory xpr;

brfc::Query q = fc.query();

// mark attribute for fetching
q.fetch(xpr.attribute("file:uuid"));
// execute
shared_ptr<brfc::ResultSet> r = q.execute();

// loop through results
while (r->next()) {
    // access the values
    brfc::String path = r->string(0);
}
@endcode

A problem you might encounter is when a file has the same attribute specified
in many datasets. You will get as many rows as the number of values for the
attribute. As in SQL, you can set a query to fetch only distinct rows using
brfc::db::AttributeQuery::distinct.

@section combine_datetime combining date and time

ODIM_H5 stores date and time values separately, so complex filters are needed
to accomodate for date changes. There's a more convenient way to handle this
situation. Add together the date and time attributes. As this is probably quite
frequently encountered, brfc::expr::ExpressionFactory provides a shorthand just
for that. Again, an example:

@code
brfc::expr::ExpressionFactory xpr;

brfc::expr::ExpressionPtr x = xpr.combined_datetime("what/date", "what/time");

DateTime now = DateTime::utc_now();
TimeDelta dt;
dt.add_minutes(-15);
DateTime past = now - dt;

// use in filter;
brfc::db::FileQuery q = fc.query_file();
q.filter(x->between(past, now));
@endcode

@section removing Removing files

File removal is done using a brfc::db::FileEntry instance, probably attained
thorugh querying.

for example, removing files older than from 2009.
@code
brfc::FileCatalog fc(dsn, storage_dir);
brfc::expr::ExpressionFactory xpr;

brfc::db::FileQuery q = fc.query_file();

q.filter(xpr.attribute("what/date")->lt(xpr.date(2009, 1, 1)));

shared_ptr<brfc::db::FileResult> r = q.execute();

while (r->next()) {
    try {
        fc.remove(r->entry());
    } catch (const brfc::db_error& e) {
        // removing from database failed
    }
}
@endcode

@section java_bindings Java bindings

Mapping to Java code is quite straightforward. The main package name is
@c eu.baltrad.fc, this is where namespace brfc is mapped to. All exposed
subnamespaces map to subpackages (brfc::expr is @c eu.baltrad.fc.expr and
so on).

There are a few differences though:

@li brfc::brfc_error is mapped to @c eu.baltrad.fc.FileCatalogError
@li brfc::fs_error is mapped to @c eu.baltrad.fc.FileSystemError
@li brfc::db_error is mapped to @c eu.baltrad.fc.DatabaseError
@li brfc::lookup_error is mapped to @c eu.baltrad.fc.LookupError
@li brfc::duplicate_entry is mapped to @c eu.baltrad.fc.DuplicateEntry

@section java_samples Sample Java code

Querying:

@code
import eu.baltrad.fc.FileCatalog;
import eu.baltrad.fc.db.FileEntry;
import eu.baltrad.fc.db.FileQuery;
import eu.baltrad.fc.expr.ExpressionFactory;

// setting up
String dsn("postgresql://baltrad:baltrad@localhost/baltrad");
FileCatalog fc;

try {
    fc = new FileCatalog(dsn);
} catch (DatabaseError e) {
    // problem connecting to database
}

// querying
ExpressionFactory xpr;

FileQuery q = fc.query_file();
q.filter(xpr.attribute("what/source:node").eq(xpr.string("seang"));

// execute
FileResult r = q.execute();

// loop through results
while (r.next()) {
    // access the values
    FileEntry e = r.entry();
}
@endcode

*/
// vim:filetype=doxygen:et:ts=4:sw=4:tw=79
