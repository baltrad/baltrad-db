/**
@page manual Manual

@section toc Table of Contents
<ul>
  <li>@ref intro</li>
  <li>@ref setup</li>
  <li>@ref file_storing</li>
  <li>@ref file_entry</li>
  <li>@ref querying</li>
  <ul>
    <li>@ref query_filtering</li>
    <li>@ref query_limiting</li>
    <li>@ref query_ordering</li>
    <li>@ref virtual_attributes</li>
    <li>@ref querying_attributes</li>
    <li>@ref combine_datetime</li>
  </ul>
  <li>@ref removing</li>
  <li>@ref source_management</li>
  <li>@ref file_catalog</li>
  <li>@ref java_bindings</li>
  <li>@ref java_samples</li>
</ul>

@section intro Introduction

baltrad-db is a library for storing ODIM_H5 files in a database and providing
queries on the file metadata. The following is an overview of the capabilities
and common tasks. You should refer to the API documentation for details.

@note The examples used here use plain pointers for simplicity. A lot of
methods actually expect you to take the ownership of the returned pointers -
so do that and avoid memory leaks.

@section setup Setting up

You can establish a database connection through brfc::db::Database::create(). It
accepts the connection string as an URI. Currently only postgresql:// is
supported.

@code
brfc::db::Database* db = 0;
try {
    db = brfc::db::Database::create("postgresql://baltrad:baltrad@localhost/baltrad");
} catch (const brfc::db_error& e) {
    // problem connecting to the database
}
@endcode

@section file_storing Storing files in the database

Importing a file requires feeding a brfc::oh5::PhysicalFile instance to
brfc::db::Database::store(). This call will first perform a source lookup
in the database. The attribute /what/source in the file must uniquely identify
a source definition in the database (see @ref source_management). Second, it
will determine if the file itself is unique - i.e this file is not stored
already in the database. If one of those steps fails, the file will not be
stored in the database. On success, a brfc::db::FileEntry instance is
returned - this is the file, as stored in the database. You can now remove
the file from your filesystem if you want - you can bring it back later from
the database.

The database will assign an UUID to the entry. Same file imported twice will
have a different UUID (but the same metadata hash).

@code
brfc::db::Database* db; // assuming a database

brfc::oh5::hl::HlFile file("/path/to/file.h5");

brfc::db::FileEntry* entry = 0;
std::string uuid;

try {
    entry = db->store(file);
    uuid = entry->uuid();
} catch (const brfc::db_error& e) {
    // problem storing file in database
} catch (const brfc::duplicate_entry& e) {
    // file already stored
}
@endcode

There are also methods for checking if a file is already stored
(brfc::db::Database::is_stored()) and storing it "safely"
(brfc::db::Database::get_or_store()), refer to their documentation for details.

@section file_entry FileEntry - files in the database

brfc::db::FileEntry implements brfc::oh5::File, using the database as a
backend. It also provides access to some additional metadata - storage time,
UUID, file size. As this represents the file in the database, there's also a
method for writing the file back from the database to the local disk.

You can get a hold of an entry in three ways: by knowing the UUID of the entry,
by the physical file or by querying the database.

@code
brfc::db::Database* db; // assuming a database

std::string uuid = "8774632c-dfd9-4016-bebb-f9f8cf41459a";
brfc::db::FileEntry* entry = db->entry_by_uuid(uuid);

// access ODIM_H5 metadata as brfc::oh5::File
std::string what_object = entry->what_object();
brfc::oh5::Group* grp = entry->group("/dataset1/what");
brfc::oh5::Attribute* attr = grp->attribute("elangle");
brfc::oh5::Scalar elangle = attr->value();

// access additional metadata
brfc::DateTime dt = entry->stored_at();
std::string uuid = entry->uuid();
int64_t size = entry->size();

// write to disk
entry->write_to_file("/path/to/file.h5");
@endcode

@section querying Querying the database

To query for entries in the database, you must create a brfc::db::FileQuery
instance and execute it on the database. This will return a
brfc::db::FileResult instance. Simply creating the query (and not specifying
any details) will query for all the files in the database.

@code
brfc::db::Database* db; // assuming a database

brfc::db::FileQuery query;

brfc::db::FileResult* rset = db->execute(query);

rset->size(); // how many files

// loop through the entries
brfc::db::FileEntry* entry;
while (rset->next()) {
    entry = rset->entry();
    // do something useful
}
@endcode

@section query_filtering Adding filters to a query

To be more useful, you can add a filter to the query. Filters are composed of
brfc::expr::Expression elements. The easiest way to create these is using
brfc::expr::ExpressionFactory. To give an example, lets filter for all file
that have an attribute "what/object" equal to "PVOL":

@code
// create the factory
brfc::expr::ExpressionFactory xpr;

// create the query
brfc::db::FileQuery q;
q.filter(xpr.eq(xpr.attribute("what/object"), xpr.string("PVOL")));
@endcode

Successive filters can be given, meaning all specified filters must match and
is equivalent to using operator brfc::expr::Expression::and_ between the filter
expressions.

@note when you use an attribute in a filter, that attribute @b MUST
be present in the file metadata. If it's missing, it's not matching and
is thus ignored completely. There is no way to specifiy a missing value
yet (so this is a known limitation in current implementation).

@section virtual_attributes Virtual attributes

In addition to standard ODIM_H5 attributes, there are some special attributes.
They don't really exist in the metadata and require special handling, but they
are usable in the queries.

Here's a list of them:

  - file\:uuid - universally unique id of the file in database
  - file\:stored_at - when was the file imported to the database
  - file\:size - size of the file in bytes
  - src:_name - the name of the source in database
  - src:X - source key in database, where X is the source key (PLC, CTY, ...)

@section query_limiting Skipping/limiting query results

@code
brfc::db::FileQuery q;
q.limit(10) // fetch 10 files
q.skip(5) // skipping 5 files 
@endcode

@section query_ordering Ordering query results

Query results can be ordered through brfc::db::FileQuery::order_by(). By default,
they are ordered by the time of storing, oldest files first. For an example,
to sort the smallest files first:

@code
brfc::db::FileQuery q;
q.order_by(xpr.attribute("file:size"), brfc::db::FileQuery::ASC);
@endcode

@section querying_attributes Querying attributes

Sometimes you will want to query for specific attributes instead of files.
brfc::db::AttributeQuery enables you to do just that. In addition to filtering,
you can specify which attributes to fetch from the database. So to query for
all files in the database, you would do this:

@code
brfc::db::Database* db; // assuming a database
brfc::expr::ExpressionFactory xpr;

brfc::db::AttributeQuery q;

// mark attribute for fetching
q.fetch(xpr.attribute("file:uuid"));
// execute
brfc::db::AttributeResult* r = q.execute();

// loop through results
while (r->next()) {
    // access the values
    std::string path = r->string(0);
}
@endcode

A problem you might encounter is when a file has the same attribute specified
in many datasets. You will get as many rows as the number of values for the
attribute. As in SQL, you can set a query to fetch only distinct rows using
brfc::db::AttributeQuery::distinct.

@section combine_datetime combining date and time

ODIM_H5 stores date and time values separately, so complex filters are needed
to accomodate for date changes. There's a more convenient way to handle this
situation. Add together the date and time attributes. As this is probably quite
frequently encountered, brfc::expr::ExpressionFactory provides a shorthand just
for that. Again, an example:

@code
brfc::expr::ExpressionFactory xpr;

brfc::expr::ExpressionPtr x = xpr.combined_datetime("what/date", "what/time");

DateTime now = DateTime::utc_now();
TimeDelta dt;
dt.add_minutes(-15);
DateTime past = now - dt;

// use in filter;
brfc::db::FileQuery q;
q.filter(x->between(past, now));
@endcode

@section removing Removing files

File removal is done using a brfc::db::FileEntry instance, probably attained
through querying.

for example, removing files older than from 2009:

@code
brfc::db::Database* db; // assuming a database
brfc::expr::ExpressionFactory xpr;

brfc::db::FileQuery q;
q.filter(xpr.attribute("what/date")->lt(xpr.date(2009, 1, 1)));

brfc::db::FileResult* r = q.execute();

while (r->next()) {
    try {
        db->remove(r->entry());
    } catch (const brfc::db_error& e) {
        // removing from database failed
    }
}
@endcode

@section source_management Managing source definitions

As mentioned before, you can't import files to the database if the database
can't look up and associate a source with the file. You can manage to source
definitions in the database through brfc::db::Database::sources(),
brfc::db::Database::add_source(), brfc::db::Database::update_source() and
brfc::db::Database::remove_source().

@section file_catalog FileCatalog - combining Database with LocalStorage

To simplify the interaction, you can combine a database and local storage in
brfc::FileCatalog. This class provides methods for storing and removing files
from the database, which in addition will store/remove the file to/from
local storage. By default brfc::FileCatalog uses brfc::NullStorage, so it's
pretty much equivalent to just using a brfc::db::Database on its own.

Combining the two might be handy, as the files imported to the database are
probably going to get used in some way in the immeditate future. Prestoring
them avoids the overhead of fetching the file back from the database to local
disk (opting to copy it on import instead).

@section java_bindings Java bindings

Mapping to Java code is quite straightforward. The main package name is
@c eu.baltrad.fc, this is where namespace brfc is mapped to. All exposed
subnamespaces map to subpackages (brfc::expr is @c eu.baltrad.fc.expr and
so on).

There are a few differences though:

@li brfc::brfc_error is mapped to @c eu.baltrad.fc.FileCatalogError
@li brfc::fs_error is mapped to @c eu.baltrad.fc.FileSystemError
@li brfc::db_error is mapped to @c eu.baltrad.fc.DatabaseError
@li brfc::lookup_error is mapped to @c eu.baltrad.fc.LookupError
@li brfc::duplicate_entry is mapped to @c eu.baltrad.fc.DuplicateEntry

@section java_samples Sample Java code

Querying:

@code
import eu.baltrad.fc.FileCatalog;
import eu.baltrad.fc.db.Database;
import eu.baltrad.fc.db.FileEntry;
import eu.baltrad.fc.db.FileQuery;
import eu.baltrad.fc.expr.ExpressionFactory;

// setting up
String dsn("postgresql://baltrad:baltrad@localhost/baltrad");
Database db = null;
try {
    Database db = Database.create(dsn);        
} catch (DatabaseError e) {
    // problem connecting to database
}

FileCatalog fc(db);

// querying
ExpressionFactory xpr;

FileQuery q = fc.query_file();
q.filter(xpr.attribute("what/source:_name").eq(xpr.string("seang"));

// execute
FileResult r = q.execute();

// loop through results
while (r.next()) {
    // access the values
    FileEntry e = r.entry();
}
@endcode

*/
// vim:filetype=doxygen:et:ts=4:sw=4:tw=79
